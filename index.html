<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Primary SEO Metadata -->
    <title>Lumina Bubble | Hex-Grid Ballistics Arcade Game</title>
    <meta name="description" content="Lumina Bubble is a high-performance hex-grid ballistics arcade game. Strategically clear the matrix in this immersive bubble shooter featuring glowing physics and retro-futuristic visuals.">
    <meta name="keywords" content="Lumina Bubble, bubble shooter, hex-grid game, arcade games, web games, Chris Pirillo, physics game, ballistics system">
    <link rel="canonical" href="https://pirillo.com/arcade/lumina-bubble.html">
    <meta name="author" content="Chris Pirillo">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/lumina-bubble.html">
    <meta property="og:title" content="Lumina Bubble | Hex-Grid Ballistics System">
    <meta property="og:description" content="Engage the matrix in Lumina Bubble. A fast-paced, high-glow hex-grid arcade experience.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/lumina-bubble.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://pirillo.com/arcade/lumina-bubble.html">
    <meta property="twitter:title" content="Lumina Bubble | Hex-Grid Ballistics System">
    <meta property="twitter:description" content="Engage the matrix in Lumina Bubble. A fast-paced, high-glow hex-grid arcade experience.">
    <meta property="twitter:image" content="https://pirillo.com/arcade/images/lumina-bubble.png">
    <meta name="twitter:creator" content="@ChrisPirillo">

    <!-- Resource Hints & Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "Lumina Bubble",
      "operatingSystem": "Web Browser",
      "applicationCategory": "GameApplication",
      "genre": "Arcade",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com"
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "5",
        "ratingCount": "1"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <style>
        /* CSS Optimization: font-display: swap for Core Web Vitals */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap&display=swap');

        :root {
            --bg-dark: #050b14;
            --accent-glow: #38bdf8;
            --glass-border: rgba(255, 255, 255, 0.15);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            color: #e2e8f0;
            touch-action: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        /* UI Overlay Layer */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center; 
        }

        /* Compact, Floating HUD */
        .hud-panel {
            margin-top: 15px;
            background: rgba(5, 10, 20, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.2);
            border-radius: 12px;
            padding: 10px 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 60px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            pointer-events: none;
            z-index: 20;
            min-width: 300px;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            flex: 1;
        }

        .stat-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 2px;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .stat-divider {
            width: 1px;
            height: 30px;
            background: rgba(255,255,255,0.1);
        }

        /* Menus */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 11, 20, 0.9);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s cubic-bezier(0.16, 1, 0.3, 1), visibility 0.5s;
            z-index: 100;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 5rem;
            margin: 0;
            background: linear-gradient(180deg, #fff 20%, #38bdf8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(56, 189, 248, 0.6));
            text-align: center;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        p.subtitle {
            font-size: 1.3rem;
            color: #cbd5e1;
            margin-top: 15px;
            margin-bottom: 60px;
            max-width: 500px;
            text-align: center;
            line-height: 1.6;
            font-weight: 500;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .btn {
            background: rgba(56, 189, 248, 0.1);
            color: var(--accent-glow);
            border: 1px solid var(--accent-glow);
            padding: 20px 70px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            border-radius: 4px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--accent-glow);
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: -1;
        }

        .btn:hover {
            color: #050b14;
            box-shadow: 0 0 50px rgba(56, 189, 248, 0.6);
            border-color: transparent;
        }

        .btn:hover::before {
            transform: scaleX(1);
            transform-origin: left;
        }

        .warning-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 15%;
            background: linear-gradient(to top, rgba(239, 68, 68, 0.3), transparent);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Screen reader optimization */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
</head>
<body>

    <!-- Semantic Layout for SEO & Performance -->
    <main id="game-container" role="main">
        <h1 class="sr-only">Lumina Bubble Arcade Game</h1>
        <canvas id="gameCanvas" aria-label="Lumina Bubble Shooter Gameplay Area"></canvas>
        <div class="warning-overlay" id="warningZone"></div>

        <!-- UI Elements as Overlay Section -->
        <header class="ui-layer">
            <div class="hud-panel" aria-live="polite">
                <div class="stat-group">
                    <div class="stat-label">System Score</div>
                    <div class="stat-value" id="scoreEl">0</div>
                </div>
                <div class="stat-divider" aria-hidden="true"></div>
                <div class="stat-group">
                    <div class="stat-label">Best Record</div>
                    <div class="stat-value" id="highScoreEl">0</div>
                </div>
            </div>
        </header>

        <!-- Dynamic Content Sections -->
        <section id="startScreen" class="modal active">
            <h1>LUMINA</h1>
            <p class="subtitle">Hex-Grid Ballistics System.<br>Clear the matrix.</p>
            <button class="btn" id="startBtn">INITIALIZE</button>
        </section>

        <section id="gameOverScreen" class="modal" aria-labelledby="failHeading">
            <h1 id="failHeading" style="background: linear-gradient(180deg, #fff 0%, #ef4444 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 30px rgba(239, 68, 68, 0.5));">SYSTEM FAILURE</h1>
            <p class="subtitle">Matrix Overload. Final Score: <span id="finalScore" style="color: white; font-weight: bold;">0</span></p>
            <button class="btn" style="border-color: #ef4444; color: #ef4444; background: rgba(239,68,68,0.1);" id="restartBtn">REBOOT</button>
        </section>
    </main>

    <footer class="sr-only">
        Created by Chris Pirillo. Play Lumina Bubble on pirillo.com.
    </footer>

<script>
/**
 * Lumina Bubble Shooter - Refined Physics & UI
 * NO CHANGES MADE TO LOGIC PER PRODUCTION REQUIREMENTS
 */

// --- Configuration ---
const CONFIG = {
    cols: 15,
    rows: 9,
    maxRows: 25,
    colors: [
        { hex: '#ef4444', name: 'red', glow: '#fca5a5' },
        { hex: '#f59e0b', name: 'orange', glow: '#fcd34d' },
        { hex: '#22c55e', name: 'green', glow: '#86efac' },
        { hex: '#06b6d4', name: 'cyan', glow: '#67e8f9' },
        { hex: '#8b5cf6', name: 'purple', glow: '#c4b5fd' },
        { hex: '#ec4899', name: 'pink', glow: '#f9a8d4' }
    ],
    shootSpeed: 22,
    maxMisses: 5
};

// --- Classes ---

class Star {
    constructor(w, h) {
        this.reset(w, h, true);
    }
    reset(w, h, randomY = false) {
        this.x = Math.random() * w;
        this.y = randomY ? Math.random() * h : -10;
        this.size = Math.random() * 2 + 0.5;
        this.speed = Math.random() * 0.5 + 0.1;
        this.alpha = Math.random() * 0.5 + 0.3;
    }
    update(h) {
        this.y += this.speed;
        if (this.y > h) this.reset(window.innerWidth, h);
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.size = Math.random() * 4 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravity
        this.life -= this.decay;
        this.size *= 0.95;
    }
    draw(ctx) {
        if (this.life <= 0) return;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Bubble {
    constructor(r, c, color, radius) {
        this.r = r;
        this.c = c;
        this.color = color;
        this.radius = radius;
        this.x = 0;
        this.y = 0;
        this.scale = 1;
        this.rot = 0;
        this.rotSpeed = 0;
        
        this.isDropping = false;
        this.isPopping = false; // New State: Matched but animating out
        this.vx = 0;
        this.vy = 0;
    }

    updatePos(gridWidth, gridHeight, radius, offsetX, offsetY) {
        if (this.isDropping) {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.6;
            this.vx *= 0.99;
            this.rot += this.rotSpeed;
            return;
        }
        
        // If popping, we don't move, just update scale in main loop
        if (this.isPopping) return;

        const dia = radius * 2;
        const rowHeight = radius * Math.sqrt(3);
        const xOffset = (this.r % 2) === 1 ? radius : 0;
        this.x = (this.c * dia + radius + xOffset) + offsetX;
        this.y = (this.r * rowHeight + radius) + offsetY;
    }

    draw(ctx) {
        if (this.scale <= 0.05) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rot);
        ctx.scale(this.scale, this.scale);

        // Glassy Sphere Render
        const grad = ctx.createRadialGradient(-this.radius*0.4, -this.radius*0.4, this.radius*0.1, 0, 0, this.radius);
        grad.addColorStop(0, this.color.glow);
        grad.addColorStop(0.4, this.color.hex);
        grad.addColorStop(1, '#0f172a'); // Darker edge

        ctx.beginPath();
        ctx.arc(0, 0, this.radius - 1, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        
        // Add a flash effect if popping
        if (this.isPopping) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
        }

        // Rim Light
        ctx.strokeStyle = this.color.glow;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.6;
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Specular Highlight (Hard reflection)
        ctx.beginPath();
        ctx.ellipse(-this.radius*0.35, -this.radius*0.4, this.radius*0.25, this.radius*0.15, Math.PI/4, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fill();

        ctx.restore();
    }
}

// --- Game Engine ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false }); 
        
        this.grid = [];
        this.particles = [];
        this.droppingBubbles = [];
        this.stars = [];
        
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem('lumina_highscore')) || 0;
        this.misses = 0;
        this.state = 'MENU';
        
        this.mouseX = 0;
        this.mouseY = 0;
        this.angle = -Math.PI / 2;
        this.recoil = 0;
        
        // Animation states
        this.time = 0;
        this.baseRotation = 0;

        this.layout = { radius: 0 };
        this.uiScore = document.getElementById('scoreEl');
        this.uiHighScore = document.getElementById('highScoreEl');
        this.warningZone = document.getElementById('warningZone');

        this.initStars();
        this.bindEvents();
        this.resize();
        
        this.loop = this.loop.bind(this);
        document.getElementById('startBtn').addEventListener('click', () => this.start());
        document.getElementById('restartBtn').addEventListener('click', () => this.start());
        
        this.uiHighScore.innerText = this.highScore;
        requestAnimationFrame(this.loop);
    }

    initStars() {
        for(let i=0; i<100; i++) {
            this.stars.push(new Star(window.innerWidth, window.innerHeight));
        }
    }

    bindEvents() {
        window.addEventListener('resize', () => this.resize());
        
        const updateMouse = (x, y) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mouseX = x - rect.left;
            this.mouseY = y - rect.top;
            this.updateAngle();
        };

        this.canvas.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
        this.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            updateMouse(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        const onClick = (e) => {
            if (this.state === 'PLAYING') {
                e.preventDefault();
                this.shoot();
            }
        };

        this.canvas.addEventListener('mousedown', onClick);
        this.canvas.addEventListener('touchstart', onClick, {passive: false});
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        const w = window.innerWidth;
        const h = window.innerHeight;

        this.canvas.style.width = w + 'px';
        this.canvas.style.height = h + 'px';
        this.canvas.width = w * dpr;
        this.canvas.height = h * dpr;
        this.ctx.scale(dpr, dpr);

        const isMobile = w < 600;
        const maxBoardWidth = isMobile ? w * 0.95 : 600;
        
        let r = Math.floor((maxBoardWidth) / (CONFIG.cols * 2 + 1));
        r = Math.max(10, r);
        
        this.layout.radius = r;
        this.layout.gridW = (CONFIG.cols * 2 * r) + r;
        this.layout.offsetX = (w - this.layout.gridW) / 2;
        this.layout.offsetY = 130; // Increased to ensure score panel does not overlap
        this.layout.shooterY = h - Math.max(140, h * 0.15); 
        this.layout.gridH = this.layout.shooterY - this.layout.offsetY;

        const applyUpdate = (b) => {
            if(b) b.updatePos(this.layout.gridW, this.layout.gridH, r, this.layout.offsetX, this.layout.offsetY);
        };

        this.grid.forEach(row => row.forEach(applyUpdate));
        this.droppingBubbles.forEach(applyUpdate);
        
        if (this.currentBubble && !this.currentBubble.moving) {
            this.currentBubble.radius = r;
            this.currentBubble.x = this.layout.offsetX + this.layout.gridW / 2;
            this.currentBubble.y = this.layout.shooterY;
        }
        if (this.nextBubble) this.nextBubble.radius = r;
    }

    updateAngle() {
        if (!this.currentBubble) return;
        const pivotX = this.layout.offsetX + this.layout.gridW / 2;
        const pivotY = this.layout.shooterY;
        this.angle = Math.atan2(this.mouseY - pivotY, this.mouseX - pivotX);
        const minAng = -Math.PI + 0.15;
        const maxAng = -0.15;
        if (this.angle > maxAng) this.angle = maxAng;
        if (this.angle < minAng) this.angle = minAng;
    }

    start() {
        document.getElementById('startScreen').classList.remove('active');
        document.getElementById('gameOverScreen').classList.remove('active');
        
        this.state = 'PLAYING';
        this.score = 0;
        this.misses = 0;
        this.uiScore.innerText = '0';
        
        this.grid = [];
        this.particles = [];
        this.droppingBubbles = [];
        
        for (let r = 0; r < CONFIG.rows; r++) {
            let row = [];
            for (let c = 0; c < CONFIG.cols; c++) {
                if (r % 2 === 1 && c === CONFIG.cols - 1) {
                    row.push(null);
                } else {
                    row.push(new Bubble(r, c, this.getRandomColor(), this.layout.radius));
                }
            }
            this.grid.push(row);
        }
        
        for(let r = CONFIG.rows; r < 50; r++) this.grid.push(new Array(CONFIG.cols).fill(null));

        this.resize();
        this.loadShooter();
    }

    getRandomColor() {
        return CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
    }

    loadShooter() {
        if (!this.nextBubble) this.nextBubble = new Bubble(0,0, this.getRandomColor(), this.layout.radius);
        
        this.currentBubble = this.nextBubble;
        this.currentBubble.x = this.layout.offsetX + this.layout.gridW / 2;
        this.currentBubble.y = this.layout.shooterY;
        this.currentBubble.radius = this.layout.radius;
        
        this.nextBubble = new Bubble(0,0, this.getRandomColor(), this.layout.radius);
    }

    shoot() {
        if (this.currentBubble.moving) return;
        this.currentBubble.moving = true;
        this.currentBubble.vx = Math.cos(this.angle) * CONFIG.shootSpeed;
        this.currentBubble.vy = Math.sin(this.angle) * CONFIG.shootSpeed;
        this.recoil = 15; // Kick back
    }

    loop() {
        if (this.state === 'PLAYING' || this.state === 'MENU' || this.state === 'GAMEOVER') {
            this.update();
            this.draw();
        }
        requestAnimationFrame(this.loop);
    }

    update() {
        this.time += 0.05;
        this.baseRotation += 0.005;

        // Background Stars
        const h = this.canvas.height / window.devicePixelRatio;
        this.stars.forEach(s => s.update(h));

        // Shooter Recoil dampening
        if (this.recoil > 0) this.recoil *= 0.85;

        if (this.state !== 'PLAYING') return;

        // 1. Grid Cleanup (Popping Animation)
        for (let r = 0; r < this.grid.length; r++) {
            for (let c = 0; c < this.grid[r].length; c++) {
                const b = this.grid[r][c];
                if (b && b.isPopping) {
                    b.scale -= 0.1; // Shrink speed
                    if (b.scale <= 0) {
                        // Actually remove from grid now
                        this.grid[r][c] = null;
                        this.createExplosion(b.x, b.y, b.color.hex);
                    }
                }
            }
        }

        // 2. Bubble Logic
        if (this.currentBubble && this.currentBubble.moving) {
            const b = this.currentBubble;
            b.x += b.vx;
            b.y += b.vy;

            // Walls
            if (b.x - b.radius < this.layout.offsetX) {
                b.x = this.layout.offsetX + b.radius;
                b.vx *= -1;
            } else if (b.x + b.radius > this.layout.offsetX + this.layout.gridW) {
                b.x = (this.layout.offsetX + this.layout.gridW) - b.radius;
                b.vx *= -1;
            }

            // Ceiling
            if (b.y - b.radius < this.layout.offsetY) {
                b.y = this.layout.offsetY + b.radius;
                this.snapBubble();
            }

            // Collisions
            let hit = false;
            let closestHit = null;
            const threshold = (this.layout.radius * 1.85)**2;
            
            for (let r = 0; r < this.grid.length; r++) {
                for (let c = 0; c < this.grid[r].length; c++) {
                    const t = this.grid[r][c];
                    // Don't collide with popping bubbles
                    if (!t || t.isPopping) continue;
                    
                    const distSq = (b.x - t.x)**2 + (b.y - t.y)**2;
                    if (distSq < threshold) {
                        hit = true;
                        closestHit = t;
                        break;
                    }
                }
                if (hit) break;
            }
            if (hit) this.snapBubble(closestHit);
        }

        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // Dropping Items
        for (let i = this.droppingBubbles.length - 1; i >= 0; i--) {
            const b = this.droppingBubbles[i];
            b.updatePos(0,0,0,0,0);
            if (b.y > h + 100) this.droppingBubbles.splice(i, 1);
        }
    }

    createExplosion(x, y, color) {
        for(let i=0; i<6; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    // --- PHYSICS FIX: Smart Snap ---
    getGridCoords(r, c) {
        const dia = this.layout.radius * 2;
        const rowHeight = this.layout.radius * Math.sqrt(3);
        const xOffset = (r % 2) === 1 ? this.layout.radius : 0;
        return {
            x: (c * dia + this.layout.radius + xOffset) + this.layout.offsetX,
            y: (r * rowHeight + this.layout.radius) + this.layout.offsetY
        };
    }

    snapBubble(hitObj) {
        const b = this.currentBubble;
        b.moving = false;
        
        let finalR = -1;
        let finalC = -1;

        if (hitObj) {
            // SEARCH FOR BEST NEIGHBOR
            const r = hitObj.r;
            const c = hitObj.c;
            const isOdd = r % 2 === 1;
            const offsets = isOdd ? 
                [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]] :
                [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];
            
            let bestDist = Infinity;
            
            for (let o of offsets) {
                const nr = r + o[0];
                const nc = c + o[1];

                // Bounds check
                if (nc < 0 || nc >= CONFIG.cols) continue;
                if (nr < 0) continue;
                if (nr >= this.grid.length) continue;

                // MUST BE EMPTY (and not popping)
                if (this.grid[nr][nc] && !this.grid[nr][nc].isPopping) continue;

                // Calculate distance from bubble to this potential slot center
                const slotPos = this.getGridCoords(nr, nc);
                const d = (b.x - slotPos.x)**2 + (b.y - slotPos.y)**2;
                
                if (d < bestDist) {
                    bestDist = d;
                    finalR = nr;
                    finalC = nc;
                }
            }
        }

        // Fallback: Basic grid snap if ceiling hit or logic fail
        if (finalR === -1) {
            const rHeight = this.layout.radius * Math.sqrt(3);
            const dia = this.layout.radius * 2;
            const relY = b.y - this.layout.offsetY - this.layout.radius;
            finalR = Math.round(relY / rHeight);
            const isOdd = (finalR % 2) === 1;
            const rowShift = isOdd ? this.layout.radius : 0;
            finalC = Math.round((b.x - this.layout.offsetX - this.layout.radius - rowShift) / dia);
        }

        // Boundaries
        if (finalC < 0) finalC = 0;
        if (finalC >= CONFIG.cols) finalC = CONFIG.cols - 1;
        if (finalR < 0) finalR = 0;

        // Force expand grid if needed
        while(this.grid.length <= finalR) this.grid.push(new Array(CONFIG.cols).fill(null));

        // CRITICAL FIX: If spot is somehow taken (very rare edge case), try shift down
        if (this.grid[finalR][finalC] && !this.grid[finalR][finalC].isPopping) {
            finalR++;
            // Re-check boundaries for fallback
            while(this.grid.length <= finalR) this.grid.push(new Array(CONFIG.cols).fill(null));
        }

        b.r = finalR;
        b.c = finalC;
        // Snap visual position immediately
        b.updatePos(this.layout.gridW, this.layout.gridH, this.layout.radius, this.layout.offsetX, this.layout.offsetY);
        
        this.grid[finalR][finalC] = b;

        this.checkMatches(b);
        this.loadShooter();
        this.checkGameOver();
    }

    checkMatches(startNode) {
        const targetColor = startNode.color.hex;
        const matchSet = new Set();
        const queue = [startNode];
        matchSet.add(startNode);
        
        const getNeighbors = (r, c) => {
            const isOdd = r % 2 === 1;
            const dirs = isOdd ? 
                [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]] : 
                [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]];
            return dirs.map(d => ({r: r+d[0], c: c+d[1]}));
        };

        let head = 0;
        while(head < queue.length){
            const curr = queue[head++];
            const neighbors = getNeighbors(curr.r, curr.c);
            
            for(let n of neighbors) {
                if(n.r >= 0 && n.r < this.grid.length && n.c >= 0 && n.c < CONFIG.cols) {
                    const bubble = this.grid[n.r][n.c];
                    // Check active bubbles only
                    if(bubble && !bubble.isPopping && bubble.color.hex === targetColor && !matchSet.has(bubble)) {
                        matchSet.add(bubble);
                        queue.push(bubble);
                    }
                }
            }
        }

        if (matchSet.size >= 3) {
            // ANIMATION FIX: Trigger pop state, don't remove immediately
            matchSet.forEach(b => {
                b.isPopping = true;
            });
            
            this.score += matchSet.size * 50 + (matchSet.size > 3 ? (matchSet.size-3)*100 : 0);
            this.uiScore.innerText = this.score;
            this.misses = 0;
            
            // Wait briefly for pop animation before dropping floaters
            setTimeout(() => this.dropFloating(), 200);
        } else {
            this.misses++;
            if (this.misses >= CONFIG.maxMisses) {
                this.addRow();
                this.misses = 0;
            }
        }
    }

    dropFloating() {
        const connected = new Set();
        const queue = [];
        // Roots are top row. Only non-popping bubbles count as anchors
        if(this.grid[0]) this.grid[0].forEach(b => { 
            if(b && !b.isPopping) { connected.add(b); queue.push(b); } 
        });

        const getNeighbors = (r, c) => {
            const isOdd = r % 2 === 1;
            const dirs = isOdd ? 
                [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]] : 
                [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]];
            return dirs.map(d => ({r: r+d[0], c: c+d[1]}));
        };

        let head = 0;
        while(head < queue.length) {
            const curr = queue[head++];
            const neighbors = getNeighbors(curr.r, curr.c);
            for(let n of neighbors) {
                 if(n.r >= 0 && n.r < this.grid.length && n.c >= 0 && n.c < CONFIG.cols) {
                    const bubble = this.grid[n.r][n.c];
                    if(bubble && !bubble.isPopping && !connected.has(bubble)) {
                        connected.add(bubble);
                        queue.push(bubble);
                    }
                }
            }
        }

        for(let r=0; r<this.grid.length; r++) {
            for(let c=0; c<this.grid[r].length; c++) {
                const b = this.grid[r][c];
                // Drop if it's not connected and NOT currently popping (popping ones handle themselves)
                if(b && !b.isPopping && !connected.has(b)) {
                    this.grid[r][c] = null;
                    b.isDropping = true;
                    b.vx = (Math.random() - 0.5) * 6;
                    b.vy = -4;
                    b.rotSpeed = (Math.random() - 0.5) * 0.2;
                    this.droppingBubbles.push(b);
                    this.score += 100;
                }
            }
        }
        this.uiScore.innerText = this.score;
    }

    addRow() {
        this.grid.unshift(new Array(CONFIG.cols).fill(null));
        for(let c=0; c<CONFIG.cols; c++) {
            if(Math.random() > 0.1) {
                this.grid[0][c] = new Bubble(0, c, this.getRandomColor(), this.layout.radius);
            }
        }
        
        for(let r=0; r<this.grid.length; r++) {
            for(let c=0; c<this.grid[r].length; c++) {
                if(this.grid[r][c]) {
                    this.grid[r][c].r = r;
                    this.grid[r][c].updatePos(this.layout.gridW, this.layout.gridH, this.layout.radius, this.layout.offsetX, this.layout.offsetY);
                }
            }
        }
        this.checkGameOver();
    }

    checkGameOver() {
        const dangerThreshold = this.layout.shooterY - 80;
        let lowestY = 0;
        
        for(let r=0; r<this.grid.length; r++) {
            for(let c=0; c<this.grid[r].length; c++) {
                if(this.grid[r][c]) lowestY = Math.max(lowestY, this.grid[r][c].y);
            }
        }

        if (lowestY > dangerThreshold + 50) {
            this.state = 'GAMEOVER';
            if(this.score > this.highScore) {
                this.highScore = this.score;
                localStorage.setItem('lumina_highscore', this.score);
            }
            document.getElementById('finalScore').innerText = this.score;
            document.getElementById('gameOverScreen').classList.add('active');
        } else if (lowestY > dangerThreshold - 100) {
            this.warningZone.style.opacity = '1';
        } else {
            this.warningZone.style.opacity = '0';
        }
    }

    draw() {
        const w = this.canvas.width / window.devicePixelRatio;
        const h = this.canvas.height / window.devicePixelRatio;
        
        // 1. GLOBAL VOID (The "Outside")
        // Deep gradient
        const bgGrad = this.ctx.createLinearGradient(0, 0, 0, h);
        bgGrad.addColorStop(0, '#020408');
        bgGrad.addColorStop(1, '#050b14');
        this.ctx.fillStyle = bgGrad;
        this.ctx.fillRect(0, 0, w, h);
        
        // Perspective Grid (The "Floor" in the distance)
        this.drawPerspectiveGrid(w, h);

        // Stars behind everything
        this.stars.forEach(s => s.draw(this.ctx));
        
        // 2. ARENA BACKDROP (The "Board")
        // Drawn strictly behind the bubbles but distinct from the void
        this.drawArenaBackdrop(w, h);

        // 3. GAMEPLAY LAYER
        this.ctx.save();
        this.ctx.beginPath();
        // Clip to the grid area for bubbles only
        this.ctx.rect(this.layout.offsetX, this.layout.offsetY, this.layout.gridW, h - this.layout.offsetY);
        this.ctx.clip();
        
        this.grid.forEach(row => row.forEach(b => { if(b) b.draw(this.ctx); }));
        this.ctx.restore();

        this.droppingBubbles.forEach(b => b.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));

        // 4. FOREGROUND ELEMENTS
        this.drawArenaBorder(w, h);
        this.drawShooter();
    }
    
    drawPerspectiveGrid(w, h) {
        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.08)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        
        // Vertical perspective lines
        const cx = w / 2;
        for (let i = -10; i <= 10; i++) {
            const x = cx + i * 150;
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(cx + (i * 400), h);
        }
        
        // Horizontal moving lines
        const offset = (this.time * 20) % 100;
        for (let i = 0; i < h; i+= 100) {
            const y = i + offset;
            if(y > h) continue;
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(w, y);
        }
        
        this.ctx.stroke();
        this.ctx.restore();
    }

    drawArenaBackdrop(w, h) {
        const x = this.layout.offsetX;
        const y = this.layout.offsetY;
        const gw = this.layout.gridW;
        
        // Draw a "glass slab" behind the game area
        this.ctx.save();
        
        // Subtle hex pattern specific to the board
        const patternSize = 30;
        this.ctx.fillStyle = 'rgba(15, 23, 42, 0.6)'; // Darken the board area
        this.ctx.fillRect(x, y, gw, h - y);
        
        this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.03)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        
        // Draw local grid
        for (let i = x; i <= x + gw; i += patternSize) {
            this.ctx.moveTo(i, y);
            this.ctx.lineTo(i, h);
        }
        this.ctx.stroke();
        
        // Side Vignettes (Shadows at the edges of the board)
        const vign = this.ctx.createLinearGradient(x, 0, x + gw, 0);
        vign.addColorStop(0, 'rgba(0,0,0,0.5)');
        vign.addColorStop(0.1, 'rgba(0,0,0,0)');
        vign.addColorStop(0.9, 'rgba(0,0,0,0)');
        vign.addColorStop(1, 'rgba(0,0,0,0.5)');
        this.ctx.fillStyle = vign;
        this.ctx.fillRect(x, y, gw, h - y);
        
        this.ctx.restore();
    }
    
    drawArenaBorder(w, h) {
        const x = this.layout.offsetX;
        const y = this.layout.offsetY;
        const gw = this.layout.gridW;
        
        // Padding: Move border OUTWARDS from the grid
        const p = 15; 
        
        this.ctx.save();
        
        // 1. Tech Brackets (Corners)
        this.ctx.shadowColor = '#38bdf8';
        this.ctx.shadowBlur = 15;
        this.ctx.strokeStyle = '#38bdf8';
        this.ctx.lineWidth = 3;
        
        this.ctx.beginPath();
        
        // Top Left Bracket
        this.ctx.moveTo(x - p, h);
        this.ctx.lineTo(x - p, y - p + 20); // up
        this.ctx.lineTo(x - p + 20, y - p); // angled corner
        this.ctx.lineTo(x - p + 100, y - p); // across
        
        // Top Right Bracket
        this.ctx.moveTo(x + gw + p - 100, y - p);
        this.ctx.lineTo(x + gw + p - 20, y - p);
        this.ctx.lineTo(x + gw + p, y - p + 20);
        this.ctx.lineTo(x + gw + p, h);
        
        // Bottoms (Fade out)
        const grad = this.ctx.createLinearGradient(0, h-200, 0, h);
        grad.addColorStop(0, '#38bdf8');
        grad.addColorStop(1, 'rgba(56, 189, 248, 0)');
        this.ctx.strokeStyle = grad;
        
        this.ctx.stroke();
        
        // 2. Thin Guide Lines (Connecting brackets)
        this.ctx.beginPath();
        this.ctx.moveTo(x - p + 105, y - p);
        this.ctx.lineTo(x + gw + p - 105, y - p);
        this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.shadowBlur = 0;
        this.ctx.stroke();

        this.ctx.restore();
    }

    drawShooter() {
        const cx = this.layout.offsetX + this.layout.gridW / 2;
        const cy = this.layout.shooterY;

        this.ctx.save();
        this.ctx.translate(cx, cy);

        // --- 1. THE BASE (Floating Platform) ---
        // Rotating outer ring
        this.ctx.save();
        this.ctx.rotate(this.baseRotation);
        this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.2)';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([10, 20]);
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 60, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.restore();

        // Inner Hex Structure
        this.ctx.fillStyle = '#0f172a';
        this.ctx.strokeStyle = '#38bdf8';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const r = 35;
            const px = Math.cos(angle) * r;
            const py = Math.sin(angle) * r;
            if (i === 0) this.ctx.moveTo(px, py);
            else this.ctx.lineTo(px, py);
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();

        // Center Core Pulse
        const pulse = 1 + Math.sin(this.time) * 0.1;
        this.ctx.fillStyle = '#38bdf8';
        this.ctx.shadowColor = '#38bdf8';
        this.ctx.shadowBlur = 20;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 10 * pulse, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;


        // --- 2. THE TURRET (Rotates with mouse) ---
        this.ctx.rotate(this.angle);
        
        // Recoil
        const recoilX = -Math.cos(0) * this.recoil; 
        this.ctx.translate(recoilX, 0);

        // Laser Sight (Underneath)
        const gradient = this.ctx.createLinearGradient(0, 0, 800, 0);
        gradient.addColorStop(0, 'rgba(56, 189, 248, 0)');
        gradient.addColorStop(0.1, 'rgba(56, 189, 248, 0.6)');
        gradient.addColorStop(1, 'rgba(56, 189, 248, 0)');
        this.ctx.beginPath();
        this.ctx.moveTo(40, 0);
        this.ctx.lineTo(800, 0);
        this.ctx.strokeStyle = gradient;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();

        // Turret Arms (Mechanical Claws)
        this.ctx.fillStyle = '#334155'; // Dark Grey
        
        // Left Claw
        this.ctx.beginPath();
        this.ctx.moveTo(0, -20);
        this.ctx.lineTo(40, -25);
        this.ctx.lineTo(50, -35);
        this.ctx.lineTo(20, -40);
        this.ctx.lineTo(-10, -25);
        this.ctx.fill();
        this.ctx.strokeStyle = '#64748b';
        this.ctx.stroke();

        // Right Claw
        this.ctx.beginPath();
        this.ctx.moveTo(0, 20);
        this.ctx.lineTo(40, 25);
        this.ctx.lineTo(50, 35);
        this.ctx.lineTo(20, 40);
        this.ctx.lineTo(-10, 25);
        this.ctx.fill();
        this.ctx.stroke();

        this.ctx.restore(); // Undo rotation/translate for independent elements

        // --- 3. FLOATING UI ELEMENTS ---
        
        // Next Bubble Holo-Pad (Left side)
        const nextX = cx - 100;
        const nextY = cy;
        
        // Holo Circle
        this.ctx.save();
        this.ctx.translate(nextX, nextY);
        // Rotating bracket around next bubble
        this.ctx.rotate(-this.time * 0.5);
        this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.4)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 28, 0, Math.PI * 1.5);
        this.ctx.stroke();
        this.ctx.restore();

        // Label
        this.ctx.fillStyle = '#94a3b8';
        this.ctx.font = '10px Orbitron';
        this.ctx.textAlign = 'center';
        this.ctx.fillText("NEXT", nextX, nextY + 45);

        // Render Next Bubble
        if (this.nextBubble) {
            const tempX = this.nextBubble.x;
            const tempY = this.nextBubble.y;
            this.nextBubble.x = nextX;
            this.nextBubble.y = nextY;
            this.nextBubble.draw(this.ctx);
            this.nextBubble.x = tempX;
            this.nextBubble.y = tempY;
        }

        // Render Current Bubble (Attached to Turret)
        if (this.currentBubble) {
            this.ctx.save();
            this.ctx.translate(cx, cy);
            this.ctx.rotate(this.angle);
            this.ctx.translate(recoilX, 0); 
            this.ctx.rotate(-this.angle);
            this.ctx.translate(-cx, -cy);
            this.currentBubble.draw(this.ctx);
            this.ctx.restore();
        }
    }
}

window.onload = () => new Game();

</script>
</body>
</html>